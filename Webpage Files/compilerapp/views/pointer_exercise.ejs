<!DOCTYPE html>
<html>
  <head>
    <title> <%= title %> </title>
      
    <link href="/stylesheets/pageStyle.css" type="text/css" rel="stylesheet" /> 

    <!--<link href="/stylesheets/otherStyle.css" type="text/css" rel="stylesheet" /> -->

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
      
    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
    <!-- Latest compiled JavaScript -->
    <script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
    <script>
    $(document).ready(function() {
      $("#lesson2_e1").submit(function(e){
          var url = $(this).attr("action"); // the script where you handle the form input.
          $.post(url,
          $("#lesson2_e1").serialize(),
          function(data,status){
              $("#lesson2_e1_result").text(data.result);
              $("#lesson2_e1_result").append(data.details);
          });

          e.preventDefault(); // avoid to execute the actual submit of the form.
      });

      $("#lesson2_e2").submit(function(e){
          var url = $(this).attr("action"); // the script where you handle the form input.
          $.post(url,
          $("#lesson2_e2").serialize(),
          function(data,status){
              //alert("Data: " + data + "\nStatus: " + status);
              $("#lesson2_e2_result").text(data.result);
              $("#lesson2_e2_result").append(data.details);
          });

          e.preventDefault(); // avoid to execute the actual submit of the form.
      });

      $("#lesson2_e3").submit(function(e){
          var url = $(this).attr("action"); // the script where you handle the form input.
          $.post(url,
          $("#lesson2_e3").serialize(),
          function(data,status){
              //alert("Data: " + data + "\nStatus: " + status);
              $("#lesson2_e3_result").text(data.result);
              $("#lesson2_e3_result").append(data.details);
          });

          e.preventDefault(); // avoid to execute the actual submit of the form.
      });

      $("#lesson2_e1_bt").click(function(){$("#lesson2_e1").submit()});
      $("#lesson2_e2_bt").click(function(){$("#lesson2_e2").submit()});
      $("#lesson2_e3_bt").click(function(){$("#lesson2_e3").submit()});
    });
    </script>
  </head>
    
<body>
    
  <!-- Website Title and Navigation Bar -->
  <div class="row"><br>
    <div class = "col-lg-12 top text-center">
        <font size="6" color=navy face="fantasy">Progamming Tree Foundations</font><br>
        <div class="btn-group">
          <a href="/"><button type="button" class="btn btn-primary">Home</button></a>
          <a href="/lessons"><button type="button" class="btn btn-info">Lessons</button></a>
          <a href="/signup"><button type="button" class="btn btn-warning">Register</button></a>
          <a href="/login"><button type="button" class="btn btn-success">Login</button></a>
      </div>
    </div>
  </div> 
    
<!-- Programming Tree Interface Panel -->
  <div class = "row">
    <div class = "col-lg-6">
    <!-- Content Itself, opens when user clicks something.-->
      <div class="main">
      <center>

      <!-- CONTENT OF THE PAGE -->    
          
          <h1>Pointers: Overview</h1>
              
          <p>Pointers are in C, undoubtedly, one of the most important concepts found in the language that are often misunderstood or challenging to grasp at a first glance. In this chapter, we will explore what they are in depth and will explore some of their applications used in both basic and advanced concepts of code.</p> 
              
          <h1>Section 1: So what are Pointers?</h1>
              
          <p>Pointers are in C, undoubtedly, one of the most important concepts found in the language that are often misunderstood or challenging to grasp at a first glance. In this chapter, we will explore what they are in depth and will explore some of their applications used in both basic and advanced concepts of code.</p>
              
          <!-- FORMAT: <p> </p> <br><br>-->    
              
          <p><b><u>Abstract:</u></b> A pointer is a variable container for storing memory address(es), where once a pointer is declared and assigned a value the pointer is simply represents a memory address as its value.</p>
              
          <h2> Logistics </h2>    
              
          <p> 	What does the abstract above mean? As any experienced programmer in a language knows, when in the runtime of the code there are various actions that occur behind the scenes in terms of memory allocation. Where with the local variables and invoked function calls being allocated on the Stack at runtime; and dynamically allocated variables and calls using malloc() and free() in C are being allocated in the Heap of the virtual memory address space. Whenever a variable is being declared at runtime, information about the variable is stored in memory by assigning it a specific number in the address space as follows.</p> <br><br>
              
          <img src="http://i240.photobucket.com/albums/ff108/dwakira/Address%20Space%20Basic%20no%20Pointers_zps10qvcz9b.png"><br><br>
              
          <p> While addresses in memory are represented as numbers in memory, their range of values may differ from that of integers. So in such cases where the address names cannot be stored in a regular integer variable, they are stored in integer pointer variables where in the image below the declared pointer p 'points to' the integer variable x.</p> 
          
          <img src="http://i240.photobucket.com/albums/ff108/dwakira/Address%20Space%20Basic%20with%20Pointers_zpsnhaumgod.png"><br><br>
          <img src="http://i240.photobucket.com/albums/ff108/dwakira/Pointer%20Abstractions_zpsqsqxghyw.png"><br>
          
          <h1>Pointer Declarations and Assignment</h1>
              
          <p>As one might have noticed in Figure 2, the declaration of pointers are similar to of a regular variable â€“ with the exception of an asterisk that is found before the variable name. In pointers there are two main uses of the asterisk, one which is used for the pointer variable declaration, and the other for dereferencing a variable which we will explore in the coming section. Before using the pointer in any context it is important that one must initialize it. </p> 

          <p><b><u>Variations in Code: Asterisk Declarations</u></b> </p> 
              
          <table>
          <tbody>
              <center>
          <tr>
              
          <td width="623">
          <pre id="code">
          int*  int_pointer; 
          int  *int_pointer_two;
      				</pre>
                  </td>
              </tr>
      </center>
          </tbody>
          </table> 

          <p>Just as there are different types of variables found in any C program, pointers also come with the corresponding type of what data structures' or variables' address it points to.  </p>
              
          <p> <b><u>Variations in Code:  Declarations and Assignments with live Variables</u></b></p>

          <table>
          <tbody>
              <center>
          <tr>
              
          <td width="623">
          <pre id="code">
          char y = 's';
          
          // Declaring & initializing a pointer at same instance
          char *q = &amp; y;   
              
          // In the same line: the variable must come first in such a case
          char y = 's', *q = &amp; y;  
          
          // Incorrect pointer initialization 
          char *r = y;</pre>
                  </td>
              </tr>
      </center>
          </tbody>
          </table>
              
              
              
          <p> When assigning a value to the pointer, it is found that pointers are not initialized simply by having the variable name itself. In the above examples shown so far, the indirection operator (&) is used just before the variable name. In C this operator is used to indicate that the pointer stores 'the address of variable var_name', which by definitions of a pointer is what we need. </p> 
              
          <h3>Annotations</h3>
          <table>
              <tbody>

              <tr>
              <td width="623">

              This operator is used to indicate a memory address of any variable, where this notation is not strictly limited to the use of just pointers. Whenever the programmer wishes to view the address of any variable for their program, the &amp; operator is placed before the variable of their desire.</td>
              </tr>

              </tbody>
          </table>    
          
          <h2>Pointer upon Pointers</h2>
              
          <p> One can also copy the contents of a pointer to another pointer, as shown below. But note that in the below example, the contents of one pointer cannot be initialized to another pointer as shown below. </p>
              

          <table>
          <tbody>
              <center>
          <tr>
              
          <td width="623">
          <pre id="code">
          int *p = &amp;x; 
          int *q;
          
          // Copies the contents of p into q, so both pointers point to &amp;x
          q = p;
              
          // Incorrect pointer initializations 
          *q = *p;                       

      				</pre>
                  </td>
              </tr>
      </center>
          </tbody>
          </table>
              
              
          <h2>Derefencing Pointers</h2>
          <div class = "well">    
            <p><strong><u>Example:</u></strong></p> 
            <p>printf('Address of x: %d, Pointer p is: %d \n', &amp;x, *p); </p> 
                
            <p><strong><u>Result of printf Statement:</u></strong> </p> 
            <p> Address of x: 0x007fe, Pointer p is: 9</p> 
          </div>
          <p> Look at the above example: does anything seem rather odd about the result of the print statement? The print value of x is as expected, using the &amp; operator to show the address of variable x. But what about the second instance involving pointer p? Why doesnt this print out the address of the variable x it is assigned as? </p> 
              
          <p> The answer to this question presents the second use of the asterisk in pointer notation, is that the operator is used to access the 'value' of the variable the pointer points to. Consider the following example from Figure 2, reshown below.</p>
              
          <p> int x = 9, *p = &amp;x;</p>
              
          <p> 	The variable x and value of the pointer p has been initialized correctly. But now ask yourself, is there any way to see the value of x through p? Instead of seeing what the address of x is, can we physically see the value 9? Consider the following code line below.</p> 
              
          <p>int show_value = *p; </p> 
              
          <p> Here we have declared a new integer variable, and have assigned it as '*p'. Does this return the address value of x? No. Pointers provide a second use of the asterisk, where this instance of the asterisk is commonly used <b>after a pointer</b> is declared and initialized. </p> 
              
          <img src="http://i240.photobucket.com/albums/ff108/dwakira/Dereferencing_zpskup5epf1.png"> <br><br>
              
          <p> This second use of the asterisk details as dereference the address of var_name of what my_pointer points to, and show me what the contents of var_name are. In the case of Figure 4, variable showVal stores the value of integer x, the variable whose address pointer p was pointing to.</p>
          <div class = "well">  
            <p> <strong><u>Differences in Annotations:</u></strong></p> 
            <p> int *p = &amp x; // pointer declared and initialized.</p> 
            <p> printf('Address of p: %d, Pointer value is: %d \n', p, *p); </p> 
                
            <p> <strong><u>Result of print Statement:</u></strong></p> 
            <p> Address of p: 0x007fe, Pointer value is: 9</p>
          </div>
              
          <p> So as expected, the results of the print statement returns the value as intended. Manually passing p shows the address value of the variable pointer p stores, while the second argument of the statement returns a dereferenced pointer. </p> 
              
              
              
          <h1>Section Two: Return Values and Function Parameters</h1>
              
          <p>To pass a pointer into a function, is the same thing as would happen for any regular variable.</p>
              
          <p>int tri_sum(int x, int y, int *p, int *sum) { }</p>
              
          <p>Return values follow the along the same lines, where returning a pointer in its regular notation would return a memory address.</p>
              
              <table>
          <tbody>
              <center>
          <tr>
              
          <td width="623">
          <pre id="code">
          char *pointer;
          
          // Returns memory address
          return pointer;    
          
          // Dereference: returns the value of the variable it points to  
          return *pointer;                    

      				</pre>
                  </td>
              </tr>
      </center>
          </tbody>
          </table>    
              
              

              
          <p>However when passing and initializing pointer variables to structs in C, take care of some special notations that occur. When calling a struct parameter of a pointer that points to a struct, a '->' operator is used instead of the usual '.' </p>
              
          <table>
          <tbody>
              <center>
          <tr>
              
          <td width="623">
                  <pre id="code">
          typedef struct Student {
              char[15] name;
              int age;
          }
          
          struct Student *student_one;
          char[15] name = student_one->name;
          int curr_age = student_one->age;

      				</pre>
                  </td>
              </tr>
      </center>
          </tbody>
          </table>    
          
              
          <h1>Section 3: Pointers and Arrays </h1>
          <p>	Pointers provide the functionality of pointing to an array, complete with indexing through an array using pointer notation. When initializing an array of elements and having a pointer pointing to it, the pointer first points to the first element of the array.</p>
              
          <table>
          <tbody>
              <center>
          <tr>
              
          <td width="623">
          <pre id="code">
          int[10] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
          int *p = numbers;
              
          //Where this is essentially equivalent to, and can be used in a concept 
          // such as the for loop.
          sum = 0;
          for(p = &amp;number[0]; p &lt; &amp;numbers[10]; p++) {
              sum += *p;
          }

      				</pre>
                  </td>
              </tr>
      </center>
          </tbody>
          </table>   
        </center>
      </div><!-- End of content or main -->
    </div><!-- End of main column-->
    <div class = "col-lg-6">
      <!-- Section for where the game should go --> 
      <div class="game">
        <center>
            <h1>Pointer Game!</h1>
        </center>
      </div><!-- End of game div--> 
    </div> <!--End of game column-->
  </div><!-- End of 1st row-->
    
  <!-- EXERCISES FOR THE CONTENT --> 

  <div class = "row">
    <div class = "col-lg-12">
      <div class = "lesson2_exercises">
        <center>
           <q1>
              <h1>EX.1</h1>
              Complete the function print_addr() and print the memory address of x using both printf and print_addr.
              <br>Compare the results. 
              <br>
              <form action="/ajax_compile" method="post" id="lesson2_e1">
              <br>
              Name: <input type="text" name="name">
              <button name = "lesson2_e1_bt" type="submit"> Submit</button>
              </form>
              <textarea name = "lesson_name" form="lesson2_e1" style="display:none;">Pointers</textarea>
              <textarea name = "lesson_number" form="lesson2_e1" style="display:none;">2</textarea>
              <textarea name = "exercise_name" form="lesson2_e1" style="display:none;">exercise1</textarea>

              <textarea rows="15" cols="70" name="code" form="lesson2_e1">#include <stdio.h>

        int * print_addr(int x){
          ...
        }</textarea>
            <br>
            <h1>Result</h1>
            <center>
            <div class = "result" id="lesson2_e1_result">Check your solution</div>
            </center>
            </q1>
            <br><br>
            <q2>
                <h1>EX.2</h1>
              Complete the function swap() to swap the value stored at input1 and input2. 
              <br>
              <form action="/ajax_compile"method="post" id="lesson2_e2">
              Name: <input type="text" name="name">
              <button name = "lesson2_e2_bt" type="submit"> Submit</button>
              </form>
              <textarea name = "lesson_name" form="lesson2_e2" style="display:none;">Pointers</textarea>
              <textarea name = "lesson_number" form="lesson2_e2" style="display:none;">2</textarea>
              <textarea name = "exercise_name" form="lesson2_e2" style="display:none;">exercise2</textarea>

              <textarea rows="15" cols="70" name="code" form="lesson2_e2">#include <stdio.h>
                
          void swap(<input1>, <input2>){
            ...
        }</textarea>
            <br>
            <h1>Result</h1>
            <center>
            <div class = "result" id="lesson2_e2_result">Check your solution</div>
            </center>
            </q2>
            <br><br>
            <q3>
                <h1>Ex.3</h1>
              Complete the function *new_student() for creating new struct Student.   
              <br>
              <form action="/ajax_compile"method="post" id="lesson2_e3">
              Name: <input type="text" name="name">
              <button name = "lesson2_e3_bt" type="submit"> Submit</button>
              </form>
              <textarea name = "lesson_name" form="lesson2_e3" style="display:none;">Pointers</textarea>
              <textarea name = "lesson_number" form="lesson2_e3" style="display:none;">2</textarea>
              <textarea name = "exercise_name" form="lesson2_e3" style="display:none;">exercise3</textarea>
              <textarea rows="15" cols="70" name="code" form="lesson2_e3">#include <stdio.h>
        #include <stdlib.h>

        struct Student {
            char *name;
            int u_id;
            int year;
            char *program;
        };

          //a function that creates a Student
        struct Student *new_student(<name>, <u_id>, <year>, <program>){
          ...
        }</textarea>
            <br>
            <h1>Result</h1>
            <center>
            <div class = "result" id="lesson2_e3_result">Check your solution</div>
            </center>
            </q3>
            <br><br>
      </center>
      </div>
      <!--End of exercise-->
    </div><!--End of exercise column-->
  </div><!-- End of 2nd row-->


</body>   
     
     
</html>
